#folder_path = "/share/PI/manishad/genSurv"
folder_path = "~/Desktop/delete"
runfile_path = paste(path, "/testRunFile.R", sep="")
write_path = paste(folder_path, "/sbatch_files/", 1:n.files, ".sbatch", sep="")
write_path
jobname = paste("job", 1:n.files, sep="_")
jobname
outfile = paste("rm_", 1:n.files, ".out", sep="")
errorfile = paste("rm_", 1:n.files, ".err", sep="")
sbatch_params <- data.frame(jobname,
outfile,
errorfile,
jobtime = "00:48:00",
quality = "normal",
node_number = 1,
mem_per_node = 32000,
mailtype =  "ALL",
user_email = "mmathur@stanford.edu",
tasks_per_node = 16,
cpus_per_task = 1,
path_to_r_script = paste(folder_path, "/simulate.R", sep=""),
args_to_r_script = "16 job_2 200 2 1 15",
write_path,
stringsAsFactors = F,
server_sbatch_path = NA)
sbatch_params
sbatch_params
generateSbatch(sbatch_params, runfile_path)
generateSbatch <- function(sbatch_params, runfile_path = NA, run_now = F) {
#sbatch_params is a data frame with the following columns
#jobname: string, specifies name associated with job in SLURM queue
#outfile: string, specifies the name of the output file generated by job
#errorfile: string, specifies the name of the error file generated by job
#jobtime: string in hh:mm:ss format, max (maybe soft) is 48:00:00
#specifies the amoung of time job resources should be allocated
#jobs still running after this amount of time will be aborted
#quality: kind of like priority, normal works
#node_number, integer: the number of nodes (computers w/16 cpus each) to allocate
#mem_per_node, integer: RAM, in MB, to allocate to each node
#mailtype, string: ALL, BEGIN, END, FAIL: what types of events should you be notified about via email
#user_email string: email address: email address to send notifications
#tasks_per_node: integer, number of tasks, you should probably use 1
#cpus_per_task: integer, 1-16, number of cpus to use, corresponds to number of available cores per task
#path_to_r_script: path to r script on sherlock
#args_to_r_script: arguments to pass to r script on command line
#write_path: where to write the sbatch file
#server_sbatch_path: where sbatch files will be stored on sherlock
#runfile_path is a string containing a path at which to write an R script that can be used to run
#the batch files generated by this function.
#if NA, no runfile will be written
#run_now is a boolean specifying whether batch files should be run as they are generated
browser()
sbatches <- list()
if (!is.na(runfile_path)) {
outfile_lines <- c(paste0("# Generated on ",  Sys.time()))
}
for (sbatch in 1:nrow(sbatch_params) ) {
gen_batch <- sbatch_skeleton()
#set job name
if (is.null(sbatch_params$jobname[sbatch])) {
gen_batch <- gsub("JOBNAME", "unnamed", gen_batch)
} else {
gen_batch <- gsub("JOBNAME", sbatch_params$jobname[sbatch], gen_batch)
}
#set outfile name
if (is.null(sbatch_params$outfile[sbatch])) {
gen_batch <- gsub("OUTFILE", "unnamed", gen_batch)
} else {
gen_batch <- gsub("OUTFILE", sbatch_params$outfile[sbatch], gen_batch)
}
#set errorfile name
if (is.null(sbatch_params$errorfile[sbatch])) {
gen_batch <- gsub("ERRORFILE", "unnamed", gen_batch)
} else {
gen_batch <- gsub("ERRORFILE", sbatch_params$errorfile[sbatch], gen_batch)
}
#set jobtime
if (is.null(sbatch_params$jobtime[sbatch])) {
gen_batch <- gsub("JOBTIME", "unnamed", gen_batch)
} else {
gen_batch <- gsub("JOBTIME", sbatch_params$jobtime[sbatch], gen_batch)
}
#set quality
if (is.null(sbatch_params$quality[sbatch])) {
gen_batch <- gsub("QUALITY", "unnamed", gen_batch)
} else {
gen_batch <- gsub("QUALITY", sbatch_params$quality[sbatch], gen_batch)
}
#set number of nodes
if (is.null(sbatch_params$node_number[sbatch])) {
gen_batch <- gsub("NODENUMBER", "unnamed", gen_batch)
} else {
gen_batch <- gsub("NODENUMBER", sbatch_params$node_number[sbatch], gen_batch)
}
#set memory per node
if (is.null(sbatch_params$mem_per_node[sbatch])) {
gen_batch <- gsub("MEMPERNODE", "unnamed", gen_batch)
} else {
gen_batch <- gsub("MEMPERNODE", sbatch_params$mem_per_node[sbatch], gen_batch)
}
#set requested mail message types
if (is.null(sbatch_params$mailtype[sbatch])) {
gen_batch <- gsub("MAILTYPE", "unnamed", gen_batch)
} else {
gen_batch <- gsub("MAILTYPE", sbatch_params$mailtype[sbatch], gen_batch)
}
#set email at which to receive messages
if (is.null(sbatch_params$user_email[sbatch])) {
gen_batch <- gsub("USER_EMAIL", "unnamed", gen_batch)
} else {
gen_batch <- gsub("USER_EMAIL", sbatch_params$user_email[sbatch], gen_batch)
}
#set tasks per node
if (is.null(sbatch_params$tasks_per_node[sbatch])) {
gen_batch <- gsub("TASKS_PER_NODE", "unnamed", gen_batch)
} else {
gen_batch <- gsub("TASKS_PER_NODE", sbatch_params$tasks_per_node[sbatch], gen_batch)
}
#set cpus per task
if (is.null(sbatch_params$cpus_per_task[sbatch])) {
gen_batch <- gsub("CPUS_PER_TASK", "unnamed", gen_batch)
} else {
gen_batch <- gsub("CPUS_PER_TASK", sbatch_params$cpus_per_task[sbatch], gen_batch)
}
#set path to r script
if (is.null(sbatch_params$path_to_r_script[sbatch])) {
gen_batch <- gsub("PATH_TO_R_SCRIPT", "unnamed", gen_batch)
} else {
gen_batch <- gsub("PATH_TO_R_SCRIPT", sbatch_params$path_to_r_script[sbatch], gen_batch)
}
#set args to r script
if (is.null(sbatch_params$args_to_r_script[sbatch])) {
gen_batch <- gsub("ARGS_TO_R_SCRIPT", "unnamed", gen_batch)
} else {
gen_batch <- gsub("ARGS_TO_R_SCRIPT", sbatch_params$args_to_r_script[sbatch], gen_batch)
}
#write batch file
if (is.null(sbatch_params$write_path[sbatch])) {
cat(gen_batch, file = paste0("~/sbatch_generated_at_", gsub(" |:|-", "_", Sys.time()) ), append = F)
} else {
cat(gen_batch, file = sbatch_params$write_path[sbatch], append = F)
}
if (!is.na(sbatch_params$server_sbatch_path[sbatch])) {
outfile_lines <- c(outfile_lines, paste0("system(\"sbatch ", sbatch_params$server_sbatch_path[sbatch], "\")"))
}
sbatches[[sbatch]] <- gen_batch
}
if (!is.na(runfile_path)) {
cat(paste0(outfile_lines, collapse = "\n"), file = runfile_path)
}
if(run_now) { system(paste0("R -f ", runfile_path)) }
return(sbatches)
}
generateSbatch(sbatch_params, runfile_path)
gen_batch
generateSbatch(sbatch_params, runfile_path)
write_patj
write_path
runfile_path
generateSbatch <- function(sbatch_params, runfile_path = NA, run_now = F) {
#sbatch_params is a data frame with the following columns
#jobname: string, specifies name associated with job in SLURM queue
#outfile: string, specifies the name of the output file generated by job
#errorfile: string, specifies the name of the error file generated by job
#jobtime: string in hh:mm:ss format, max (maybe soft) is 48:00:00
#specifies the amoung of time job resources should be allocated
#jobs still running after this amount of time will be aborted
#quality: kind of like priority, normal works
#node_number, integer: the number of nodes (computers w/16 cpus each) to allocate
#mem_per_node, integer: RAM, in MB, to allocate to each node
#mailtype, string: ALL, BEGIN, END, FAIL: what types of events should you be notified about via email
#user_email string: email address: email address to send notifications
#tasks_per_node: integer, number of tasks, you should probably use 1
#cpus_per_task: integer, 1-16, number of cpus to use, corresponds to number of available cores per task
#path_to_r_script: path to r script on sherlock
#args_to_r_script: arguments to pass to r script on command line
#write_path: where to write the sbatch file
#server_sbatch_path: where sbatch files will be stored on sherlock
#runfile_path is a string containing a path at which to write an R script that can be used to run
#the batch files generated by this function.
#if NA, no runfile will be written
#run_now is a boolean specifying whether batch files should be run as they are generated
sbatches <- list()
if (!is.na(runfile_path)) {
outfile_lines <- c(paste0("# Generated on ",  Sys.time()))
}
for (sbatch in 1:nrow(sbatch_params) ) {
gen_batch <- sbatch_skeleton()
#set job name
if (is.null(sbatch_params$jobname[sbatch])) {
gen_batch <- gsub("JOBNAME", "unnamed", gen_batch)
} else {
gen_batch <- gsub("JOBNAME", sbatch_params$jobname[sbatch], gen_batch)
}
#set outfile name
if (is.null(sbatch_params$outfile[sbatch])) {
gen_batch <- gsub("OUTFILE", "unnamed", gen_batch)
} else {
gen_batch <- gsub("OUTFILE", sbatch_params$outfile[sbatch], gen_batch)
}
#set errorfile name
if (is.null(sbatch_params$errorfile[sbatch])) {
gen_batch <- gsub("ERRORFILE", "unnamed", gen_batch)
} else {
gen_batch <- gsub("ERRORFILE", sbatch_params$errorfile[sbatch], gen_batch)
}
#set jobtime
if (is.null(sbatch_params$jobtime[sbatch])) {
gen_batch <- gsub("JOBTIME", "unnamed", gen_batch)
} else {
gen_batch <- gsub("JOBTIME", sbatch_params$jobtime[sbatch], gen_batch)
}
#set quality
if (is.null(sbatch_params$quality[sbatch])) {
gen_batch <- gsub("QUALITY", "unnamed", gen_batch)
} else {
gen_batch <- gsub("QUALITY", sbatch_params$quality[sbatch], gen_batch)
}
#set number of nodes
if (is.null(sbatch_params$node_number[sbatch])) {
gen_batch <- gsub("NODENUMBER", "unnamed", gen_batch)
} else {
gen_batch <- gsub("NODENUMBER", sbatch_params$node_number[sbatch], gen_batch)
}
#set memory per node
if (is.null(sbatch_params$mem_per_node[sbatch])) {
gen_batch <- gsub("MEMPERNODE", "unnamed", gen_batch)
} else {
gen_batch <- gsub("MEMPERNODE", sbatch_params$mem_per_node[sbatch], gen_batch)
}
#set requested mail message types
if (is.null(sbatch_params$mailtype[sbatch])) {
gen_batch <- gsub("MAILTYPE", "unnamed", gen_batch)
} else {
gen_batch <- gsub("MAILTYPE", sbatch_params$mailtype[sbatch], gen_batch)
}
#set email at which to receive messages
if (is.null(sbatch_params$user_email[sbatch])) {
gen_batch <- gsub("USER_EMAIL", "unnamed", gen_batch)
} else {
gen_batch <- gsub("USER_EMAIL", sbatch_params$user_email[sbatch], gen_batch)
}
#set tasks per node
if (is.null(sbatch_params$tasks_per_node[sbatch])) {
gen_batch <- gsub("TASKS_PER_NODE", "unnamed", gen_batch)
} else {
gen_batch <- gsub("TASKS_PER_NODE", sbatch_params$tasks_per_node[sbatch], gen_batch)
}
#set cpus per task
if (is.null(sbatch_params$cpus_per_task[sbatch])) {
gen_batch <- gsub("CPUS_PER_TASK", "unnamed", gen_batch)
} else {
gen_batch <- gsub("CPUS_PER_TASK", sbatch_params$cpus_per_task[sbatch], gen_batch)
}
#set path to r script
if (is.null(sbatch_params$path_to_r_script[sbatch])) {
gen_batch <- gsub("PATH_TO_R_SCRIPT", "unnamed", gen_batch)
} else {
gen_batch <- gsub("PATH_TO_R_SCRIPT", sbatch_params$path_to_r_script[sbatch], gen_batch)
}
#set args to r script
if (is.null(sbatch_params$args_to_r_script[sbatch])) {
gen_batch <- gsub("ARGS_TO_R_SCRIPT", "unnamed", gen_batch)
} else {
gen_batch <- gsub("ARGS_TO_R_SCRIPT", sbatch_params$args_to_r_script[sbatch], gen_batch)
}
#write batch file
if (is.null(sbatch_params$write_path[sbatch])) {
cat(gen_batch, file = paste0("~/sbatch_generated_at_", gsub(" |:|-", "_", Sys.time()) ), append = F)
} else {
cat(gen_batch, file = sbatch_params$write_path[sbatch], append = F)
}
if (!is.na(sbatch_params$server_sbatch_path[sbatch])) {
outfile_lines <- c(outfile_lines, paste0("system(\"sbatch ", sbatch_params$server_sbatch_path[sbatch], "\")"))
}
sbatches[[sbatch]] <- gen_batch
}
#  if (!is.na(runfile_path)) {
#    cat(paste0(outfile_lines, collapse = "\n"), file = runfile_path)
#  }
if(run_now) { system(paste0("R -f ", runfile_path)) }
return(sbatches)
}
generateSbatch(sbatch_params, runfile_path)
n.workers = 16
n.workers = 16
n.Subj = 200
obs = 2
n.Reps = 1
n.Drugs = 15
args_to_r_script = paste("--args", n.workers, jobname, obs, n.Reps, n.Drugs, sep=" ")
args_to_r_script
n.files = 2
write_path = paste(folder_path, "/sbatch_files/", 1:n.files, ".sbatch", sep="")
jobname = paste("job", 1:n.files, sep="_")
outfile = paste("rm_", 1:n.files, ".out", sep="")
errorfile = paste("rm_", 1:n.files, ".err", sep="")
args_to_r_script = paste("--args", n.workers, jobname, obs, n.Reps, n.Drugs, sep=" ")
args_to_r_script
# EDIT THIS LINE EACH TIME
n.files = 2
#folder_path = "/share/PI/manishad/genSurv"
folder_path = "~/Desktop/delete"
runfile_path = paste(path, "/testRunFile.R", sep="")
write_path = paste(folder_path, "/sbatch_files/", 1:n.files, ".sbatch", sep="")
jobname = paste("job", 1:n.files, sep="_")
outfile = paste("rm_", 1:n.files, ".out", sep="")
errorfile = paste("rm_", 1:n.files, ".err", sep="")
n.workers = 16
n.Subj = 200
obs = 2
n.Reps = 1
n.Drugs = 15
args_to_r_script = paste("--args", n.workers, jobname, obs, n.Reps, n.Drugs, sep=" ")
sbatch_params <- data.frame(jobname,
outfile,
errorfile,
jobtime = "48:00:00",
quality = "normal",
node_number = 1,
mem_per_node = 32000,
mailtype =  "ALL",
user_email = "mmathur@stanford.edu",
tasks_per_node = 16,
cpus_per_task = 1,
path_to_r_script = paste(folder_path, "/simulate.R", sep=""),
args_to_r_script,
write_path,
stringsAsFactors = F,
server_sbatch_path = NA)
sbatch_params
# EDIT THIS LINE EACH TIME
n.files = 1
#folder_path = "/share/PI/manishad/genSurv"
folder_path = "~/Desktop/delete"
runfile_path = paste(path, "/testRunFile.R", sep="")
write_path = paste(folder_path, "/sbatch_files/", 1:n.files, ".sbatch", sep="")
jobname = paste("job", 1:n.files, sep="_")
outfile = paste("rm_", 1:n.files, ".out", sep="")
errorfile = paste("rm_", 1:n.files, ".err", sep="")
n.workers = 16
n.Subj = 200
obs = 2
n.Reps = 1
n.Drugs = 15
args_to_r_script = paste("--args", n.workers, jobname, obs, n.Reps, n.Drugs, sep=" ")
sbatch_params <- data.frame(jobname,
outfile,
errorfile,
jobtime = "48:00:00",
quality = "normal",
node_number = 1,
mem_per_node = 32000,
mailtype =  "ALL",
user_email = "mmathur@stanford.edu",
tasks_per_node = 16,
cpus_per_task = 1,
path_to_r_script = paste(folder_path, "/simulate.R", sep=""),
args_to_r_script,
write_path,
stringsAsFactors = F,
server_sbatch_path = NA)
generateSbatch(sbatch_params, runfile_path)
args_to_r_script = paste("--args", n.workers, n.Subj, jobname, obs, n.Reps, n.Drugs, sep=" ")
args_to_r_script
write_path
# EDIT THIS LINE EACH TIME
n.files = 1
folder_path = "/share/PI/manishad/genCov"
#folder_path = "~/Desktop/delete"
runfile_path = paste(path, "/testRunFile.R", sep="")
write_path = paste(folder_path, "/sbatch_files/", 1:n.files, ".sbatch", sep="")
write_path
paste("sbatch ", i, ".sbatch -p manishad", sep="")
n.files
for (i in 1:n.files) {
( paste("sbatch ", i, ".sbatch -p manishad", sep="") )
}
for (i in 1:n.files) {
print( paste("sbatch ", i, ".sbatch -p manishad", sep="") )
}
print( paste("cd ", folder_path, "/sbatch_files", sep="") )
Sys.date()
Sys.Date()
system( "scp ~/Dropbox/QSU/Mathur/PCORI/PCORI_git/r/GENCOV/* mmathur@sherlock:/share/PI/manishad/genCov" )
################################# LOAD DATA AND FUNCTIONS #################################
setwd("~/Dropbox/Personal computer/Sleep/2014 sleep data")
d = read.csv("sleep_data_2.csv", header = TRUE)
library(ggplot2)
convert_hour_min = function(x) {
x2 = c()
for (i in 1:length(x)) {
hour = as.numeric( strsplit( as.character(x[i]), ":" )[[1]][1] )
min = as.numeric( strsplit( as.character(x[i]), ":" )[[1]][2] ) / 60
time = hour + min
x2[i] = time
}
return(x2)
}
overnight_time_diff = function(pm_time, am_time) {
diff.vec = c()
for (i in 1:length(pm_time) ) {
am_hour = as.numeric( strsplit( as.character(am_time[i]), ":" )[[1]][1] )
am_min = as.numeric( strsplit( as.character(am_time[i]), ":" )[[1]][2] )
pm_hour = as.numeric( strsplit( as.character(pm_time[i]), ":" )[[1]][1] )
pm_min = as.numeric( strsplit( as.character(pm_time[i]), ":" )[[1]][2] )
diff_hour = am_hour + (12 - pm_hour - 1)
diff_min = (60 - pm_min) + am_min
diff = diff_hour + diff_min/60
diff.vec[i] = diff
}
return(diff.vec)
}
################################# CALCULATE FOR REST OF LOG #################################
# clean up missing values
d[d==""] = NA
d = d[!is.na(d$drug), ]  # get rid of future cells
# convert Excel format dates
d$sleep.latency = convert_hour_min(d$sleep.latency)
d$other.awake.time = convert_hour_min(d$other.awake.time)
# calculate new sleep variables
d$time.in.bed[is.na(d$time.in.bed)] = overnight_time_diff(d$bedtime[is.na(d$time.in.bed)],
d$wake.time[is.na(d$time.in.bed)])
d$sleep.time[is.na(d$sleep.time)] = d$time.in.bed[is.na(d$sleep.time)] - d$other.awake.time[is.na(d$sleep.time)] -
d$sleep.latency[is.na(d$sleep.time)]
d$sleep.effic[is.na(d$sleep.effic)] = d$sleep.time[is.na(d$sleep.effic)] / d$time.in.bed[is.na(d$sleep.effic)]
# add integer date variable
d$date2 = 1:nrow(d)
# add a column binning it into weeks
d$sunday = 0
d$sunday[seq(8, max(d$date2), 7)] = 1
# make week variable
d$weeks.since.tx.onset = floor(d$date2 / 7) - 4
# save filled-in data
write.csv(d, "sleep_data_pretty.csv")
################################# SLEEP VARIABLE PLOTS #################################
# set labels and plot characters for different drugs
drug.labels = c("Benadryl", "Benad + Zolp", "Melat + Zolp", "Lorazepam", "Melatonin", "None + Zolpidem", "Trazodone", "Zolpidem")
drug.shapes = c("B", "C", "C", "L", "M", "Z", "T", "Z")
##### Function to Make Plot #####
# v.line.y: integer for y-coordinate of vertical line annotations
plot_continuous = function(data, var.name, y.breaks, ylab, v.line.y, point.size) {
lim1 = min(y.breaks)
lim2 = max(y.breaks)
p = (
ggplot( data=data, aes(x=date2, y=data[[var.name]], group=TRUE, shape=as.factor(drug)) ) +
geom_line(size=.9, linetype=1) + geom_point(size=4.5, color="red") +
scale_shape_manual(values=drug.shapes, labels=drug.labels, name="") +
theme_bw() +
# plot 3 quartiles
geom_hline(yintercept=median(data[[var.name]], na.rm=TRUE), linetype=2, color="grey") +
geom_hline(yintercept=mean(data[[var.name]], na.rm=TRUE), linetype=2, color="grey") +
annotate("text", x=1, y=median(data[[var.name]], na.rm=TRUE), label="Median", size=4, color="grey", vjust=-.8) +
annotate("text", x=1, y=mean(data[[var.name]], na.rm=TRUE), label="Mean", size=4, color="grey", vjust=-.8) +
###### Plot Important Dates ######
# 12/4
geom_vline(xintercept=32, linetype=2, color="black") +
annotate("text", x=32, y=v.line.y, label="12/4: Therapy onset", size=4, angle=90, vjust=-.8) +
# 12/19
geom_vline(xintercept=47, linetype=2, color="black") +
annotate("text", x=47, y=v.line.y, label="12/19: TIB 8h; Benad 50 mg", size=point.size, angle=90, vjust=-.8) +
# 12/30
geom_vline(xintercept=58, linetype=2, color="black") +
annotate("text", x=58, y=v.line.y, label="12/30: TIB 8h; Benad 50 mg", size=point.size, angle=90, vjust=-.8) +
# 1/8
geom_vline(xintercept=67, linetype=2, color="black") +
annotate("text", x=67, y=v.line.y, label="1/8: TIB 8h; Benad 25 mg", size=point.size, angle=90, vjust=-.8) +
# 1/16
geom_vline(xintercept=76, linetype=2, color="black") +
annotate("text", x=76, y=v.line.y, label="1/16: TIB 8:15; Benad 25 mg", size=point.size, angle=90, vjust=-.8) +
# Harvard visit
geom_vline(xintercept=82, linetype=2, color="blue") +
geom_vline(xintercept=83, linetype=2, color="blue") +
annotate("text", x=82, y=v.line.y, label="1/23 - 1/24: Harvard", size=4, angle=90, vjust=-.8, color="blue") +
# 1/29
geom_vline(xintercept=88, linetype=2, color="black") +
annotate("text", x=88, y=v.line.y, label="1/29: TIB 8:15; Benad 25 mg", size=point.size, angle=90, vjust=-.8) +
# 2/5
geom_vline(xintercept=95, linetype=2, color="black") +
annotate("text", x=95, y=v.line.y, label="2/5: TIB 8:15; Benad 25 mg", size=point.size, angle=90, vjust=-.8) +
# 2/12
geom_vline(xintercept=102, linetype=2, color="black") +
annotate("text", x=102, y=v.line.y, label="2/12: TIB 8:15; Benad 25 mg", size=point.size, angle=90, vjust=-.8) +
# 2/16
geom_vline(xintercept=107, linetype=2, color="black") +
annotate("text", x=107, y=v.line.y, label="(2/16: TIB 8:15; Benad 50 mg)", size=point.size, angle=90, vjust=-.8) +
# 2/19
geom_vline(xintercept=110, linetype=2, color="black") +
annotate("text", x=110, y=v.line.y, label="2/19: TIB 8:15; meds flexible", size=point.size, angle=90, vjust=-.8) +
# 2/26
geom_vline(xintercept=117, linetype=2, color="black") +
annotate("text", x=117, y=v.line.y, label="2/26: TIB 8:15; meds flexible", size=point.size, angle=90, vjust=-.8) +
# UW visit
geom_vline(xintercept=121, linetype=2, color="blue") +
geom_vline(xintercept=124, linetype=2, color="blue") +
annotate("text", x=123, y=v.line.y, label="3/2 - 3/6: UW", size=4, angle=90, vjust=0, color="blue") +
# 3/13
geom_vline(xintercept=132, linetype=2, color="black") +
annotate("text", x=132, y=v.line.y, label="1/13: Start 10-day dose blinding", size=point.size, angle=90, vjust=-.8) +
# x-axis: tick marks only on Sundays
xlab("Date (Sundays)") + ylab(ylab) + theme(axis.title = element_text(size=16) ) +
scale_x_continuous(breaks=which(data$sunday==1), labels=data$date[which(data$sunday==1)] ) +
#scale_x_continuous(breaks=seq(6, max(data$date2), 7), labels=data$date[seq(6, max(data$date2), 7)] ) +
# y-axis
scale_y_continuous( breaks=y.breaks, limits=c( lim1, lim2 ) )
)
p$plot_env = environment()
plot(p)
}
# plot each sleep variables
plot_continuous( d, "sleep.effic", y.breaks=seq(.3, 1, .05),
ylab="Sleep efficiency, prop", v.line.y=.4, point.size=4 )
